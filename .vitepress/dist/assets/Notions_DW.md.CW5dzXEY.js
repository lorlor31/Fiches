import{_ as e,c as s,o as n,a2 as a}from"./chunks/framework.mHHrDb8M.js";const g=JSON.parse('{"title":"NOTIONS Développement Web","description":"","frontmatter":{},"headers":[],"relativePath":"Notions_DW.md","filePath":"Notions_DW.md"}'),t={name:"Notions_DW.md"},i=a(`<h1 id="notions-developpement-web" tabindex="-1">NOTIONS Développement Web <a class="header-anchor" href="#notions-developpement-web" aria-label="Permalink to &quot;NOTIONS Développement Web&quot;">​</a></h1><h1 id="securite" tabindex="-1">SECURITE <a class="header-anchor" href="#securite" aria-label="Permalink to &quot;SECURITE&quot;">​</a></h1><h2 id="injection-xss-cross-site-scripting" tabindex="-1">Injection XSS (Cross Site Scripting) <a class="header-anchor" href="#injection-xss-cross-site-scripting" aria-label="Permalink to &quot;Injection XSS (Cross Site Scripting)&quot;">​</a></h2><ul><li>Principe = On injecte du <strong>code sous forme de script</strong>, en général du JS</li><li>Voies possibles : <ul><li>champs de <strong>formulaires</strong></li><li><strong>paramètres d&#39;URL</strong> : on crée un lien vers l&#39;URL modifiée</li><li>mais aussi <strong>données récupérées d&#39;une API</strong> qu&#39;on affecterait à une variable</li></ul></li><li>Buts : récupérer des infos confidentielles (local storage, token, mdp admin...) puis se les envoyer avec AJAX</li><li>Précautions : =&gt; <strong>assainir l&#39;html</strong> si on a besoin du html et pas que du contenu des éléments en <ul><li>enlevant les balises html : <strong>strip_tags de PHP</strong></li><li>transformant les balises en entités html <strong>htmlentities en PHP</strong></li><li>utilisant des librairies comme DOMPurify en JS</li><li>évitant quand ça n&#39;est pas nécessaire les innerHTML en JS, dangerouslySetInnerHTML en React...</li></ul></li><li>A creuser : il y en a des persistantes et non-persistantes et autres ??</li></ul><h2 id="ajax" tabindex="-1">AJAX <a class="header-anchor" href="#ajax" aria-label="Permalink to &quot;AJAX&quot;">​</a></h2><ul><li>Asynchronous Javascript And Xml</li><li>Technologie qui permet de <strong>faire des requêtes http de manière asynchrone, sans avoir besoin de recharger la page</strong></li><li>Peut utiliser l&#39;API du navigateur fetch(), AXIOS, XMLhttpRequest</li></ul><h2 id="injection-sql" tabindex="-1">INJECTION SQL <a class="header-anchor" href="#injection-sql" aria-label="Permalink to &quot;INJECTION SQL&quot;">​</a></h2><ul><li>Principe : on injecte une requête SQl malveillante via un <strong>formulaire / URL</strong></li><li>Voies possibles : formulaire, queryString</li><li>Buts : exécuter une requête SQl sur la BDD</li><li>Précautions : <ul><li>Avant : <strong>échappement</strong> des caractères pour transformer les &#39; &quot; \\ avec addslashes() en PHP par exep</li><li>Utiliser des <strong>requêtes préparées</strong></li></ul></li><li>Exemple de requête préparée :</li></ul><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// récupérer la valeur passée dans le formulaire</span></span>
<span class="line"><span>$username = $_POST[&#39;login&#39;];</span></span>
<span class="line"><span>// créer la requête avec un jeton (ou paramètre préparéé)</span></span>
<span class="line"><span>$query = &quot;SELECT * FROM users WHERE username = :username &quot;;</span></span>
<span class="line"><span>// on PREPARE la requête </span></span>
<span class="line"><span>$statement = $pdo-&gt;prepare($query);</span></span>
<span class="line"><span>//On remplace les jetons par les valeurs</span></span>
<span class="line"><span>$statement-&gt;execute([</span></span>
<span class="line"><span>  &quot;:username&quot; =&gt; $username</span></span>
<span class="line"><span>]);</span></span></code></pre></div><h2 id="csrf-cross-site-request-forgery" tabindex="-1">CSRF (Cross-Site Request Forgery) <a class="header-anchor" href="#csrf-cross-site-request-forgery" aria-label="Permalink to &quot;CSRF (Cross-Site Request Forgery)&quot;">​</a></h2><ul><li>Principe : on utilise la session de qqun pour faire qqch a sa place. Pour cela, on va lui envoyer par mail un lien qui va contenir une URL modifiée et on profit que sa session est tjrs connectée.</li><li>Buts : on peut changer son mdp, usurper son identité, etc...</li><li>Voies possibles : un formulaire dont l&#39;URL a une queryString pas protégée que le hacker complète avec son mdp par exp,</li><li>Précautions : =&gt; utiliser un token CSRF 1/ On génère un token aléatoire qui change à chaque affichage du formulaire et on le met dans un input hidden <code> &lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;?= $token ?&gt;&quot;&gt;</code> 2/ On stocke ce token unique en session. 3/ On l&#39;envoie en même temps que le form 4/ Le serveur va comparer le token reçu avec celui stocké en session.</li></ul><h2 id="robots-txt" tabindex="-1">ROBOTS.TXT <a class="header-anchor" href="#robots-txt" aria-label="Permalink to &quot;ROBOTS.TXT&quot;">​</a></h2><p>Ce fichier sert à préciser</p><ol><li>quels dossier/ fichiers on ne veut pas que les crawlers des moteurs de recherche <strong>explorent</strong></li><li><strong>indexent</strong></li><li><strong>sitemap</strong> Son absence peut être dangereuse si on a des données sensibles qu&#39;on ne veut pas indexer.</li></ol>`,14),r=[i];function o(l,u,p,c,d,h){return n(),s("div",null,r)}const q=e(t,[["render",o]]);export{g as __pageData,q as default};
