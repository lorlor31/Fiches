import{_ as e,c as a,o as s,a2 as n}from"./chunks/framework.CEgrwLex.js";const g=JSON.parse('{"title":"CREER UNE API AVEC SYMFONY","description":"","frontmatter":{},"headers":[],"relativePath":"symfony/API_WITH_SYMFONY.md","filePath":"symfony/API_WITH_SYMFONY.md"}'),t={name:"symfony/API_WITH_SYMFONY.md"},r=n(`<h1 id="creer-une-api-avec-symfony" tabindex="-1">CREER UNE API AVEC SYMFONY <a class="header-anchor" href="#creer-une-api-avec-symfony" aria-label="Permalink to &quot;CREER UNE API AVEC SYMFONY&quot;">​</a></h1><h2 id="controller-et-routes" tabindex="-1">CONTROLLER ET ROUTES <a class="header-anchor" href="#controller-et-routes" aria-label="Permalink to &quot;CONTROLLER ET ROUTES&quot;">​</a></h2><p>Créer un controller sans tpl : <code>bin/console make:controller --no-template</code> Installer le serializer : <code>composer require symfony/serializer-pack</code> L&#39;importer en paramètre ds le controller <code>SerializerInterface $serializer</code></p><h3 id="dans-le-controller-on-va-creer-des-routes-qui-seront-les-endpoints-de-l-api" tabindex="-1">Dans le controller, on va créer des routes qui seront les endpoints de l&#39;API : <a class="header-anchor" href="#dans-le-controller-on-va-creer-des-routes-qui-seront-les-endpoints-de-l-api" aria-label="Permalink to &quot;Dans le controller, on va créer des routes qui seront les endpoints de l&#39;API :&quot;">​</a></h3><ul><li>ça suit la même structure que des routes classiques mais attention à bien stipuler la méthode HTTP <code>#[Route(&#39;url&#39;, name: &#39;nom&#39;, methods: [&#39;methode&#39;], requirements: contraintes)]</code></li><li>on rajoute <code>: JsonResponse</code> à la fin des méthodes pour dire qu&#39;on attend bien un JSON Exemple : <code>#[Route(&#39;/api/genres/{id}/shows&#39;, name: &#39;app_api_genres_getShows&#39;, methods: [&#39;GET&#39;], requirements: [&#39;id&#39; =&gt; &#39;d+&#39;])]</code></li></ul><h3 id="on-recupere-les-json-grace-a-la-methode-json-de-l-abstractcontroller" tabindex="-1">On récupère les JSON grâce à la méthode -&gt;json() de l&#39;AbstractController <a class="header-anchor" href="#on-recupere-les-json-grace-a-la-methode-json-de-l-abstractcontroller" aria-label="Permalink to &quot;On récupère les JSON grâce à la méthode -&gt;json() de l&#39;AbstractController&quot;">​</a></h3><pre><code>\`return $this-&gt;json($data, $status = 200, $headers = [], $context = []);\`

$data = données à convertir en json
$status = code http ou réponse http
$headers = headers éventuels par exemple pour la redirection
$context = contexte d&#39;application de la sérialisation, par exemple pour les groupes 
</code></pre><h3 id="cas-du-create" tabindex="-1">Cas du Create <a class="header-anchor" href="#cas-du-create" aria-label="Permalink to &quot;Cas du Create&quot;">​</a></h3><ul><li>La route est en POST !</li><li>Bien typeHinter Request, Serializer</li><li>On récupère la data avec getContent()</li><li>En API REST, la convention est de rediriger vers la liste :</li></ul><pre><code>        $data = $request-&gt;getContent();
        $product = $serializer-&gt;deserialize($data, product::class, &#39;json&#39;);
        $entityManager-&gt;persist($product);
        $entityManager-&gt;flush();
        return $this-&gt;json(
        $product, 
        Response::HTTP_CREATED, 
        [&quot;Location&quot; =&gt; $this-&gt;generateUrl(&quot;app_products&quot;)]
        ); 
</code></pre><ul><li>Attention il peut y avoir des relations circulaires, cf normalizer ci-dessous</li></ul><h2 id="validations-et-contraintes" tabindex="-1">VALIDATIONS ET CONTRAINTES <a class="header-anchor" href="#validations-et-contraintes" aria-label="Permalink to &quot;VALIDATIONS ET CONTRAINTES&quot;">​</a></h2><ul><li>à rajouter au-dessus des propriétés des entités <a href="https://symfony.com/doc/current/reference/constraints.html" target="_blank" rel="noreferrer">https://symfony.com/doc/current/reference/constraints.html</a></li></ul><p><code> #[Assert\\NotBlank]</code> va empêcher la valeur d&#39;être nulle ou vide</p><blockquote><p>Autres exemples :</p></blockquote><ul><li>#[Assert\\NotNull]</li><li>#[Assert\\Length(min: 2)]</li><li>#[Assert\\DateTime]</li><li>#[Assert\\Choice([[&#39;ROLE_USER&#39;],[ &#39;ROLE_ADMIN&#39;]])]</li><li>#[Assert\\ExpressionSyntax( allowedVariables: [&#39;created&#39;,&#39;archived&#39;,&#39;obsolete&#39;,&#39;deleted&#39;], message : &#39;You should provide a valid status for the contract ! &#39; )]</li></ul><blockquote><p>Attention : il y a deux types de contraintes :</p></blockquote><ul><li><p>celles de Symfony : <code>#[Assert\\type(Types::DATE_IMMUTABLE)]</code></p></li><li><p>celles de Doctrine : <code>#[ORM\\Column(type: Types::DATETIME_IMMUTABLE )]</code></p></li></ul><h2 id="serializer-et-normalizer" tabindex="-1">SERIALIZER ET NORMALIZER <a class="header-anchor" href="#serializer-et-normalizer" aria-label="Permalink to &quot;SERIALIZER ET NORMALIZER&quot;">​</a></h2><p>Le composant serializer va permettre de <strong>convertir l&#39;objet en JSON = sérialiser</strong> (on désérialise qd on convertit le JSON en objet). Son installation suffit à convertir automatiquement les objets en JSON. Mais il a beaucoup d&#39;autres outils pour nous permettre de régler des problèmes courants...</p><h3 id="references-circulaires-et-groupes-d-annotation" tabindex="-1">Références circulaires et groupes d&#39;annotation <a class="header-anchor" href="#references-circulaires-et-groupes-d-annotation" aria-label="Permalink to &quot;Références circulaires et groupes d&#39;annotation&quot;">​</a></h3><p>Pour régler le problème des références circulaires lors de la récupération des données en JSON sur des entités ayant des relations avec d&#39;autres, on va utiliser les groupes :</p><ol><li>importer la classe des groupes dans l&#39;entité :</li></ol><p><code>use Symfony\\Component\\Serializer\\Annotation\\Groups;</code></p><ol start="2"><li>au-dessus de la déclaration de la classe de l&#39;entité, créer un groupe :</li></ol><p><code>#[Groups([&#39;product&#39;])]</code></p><ol start="3"><li>Pour chaque propriété, sauf celles concernant des relations, rajouter un sous-groupe :</li></ol><p><code>#[Groups([&#39;productLinked&#39;])]</code></p><ol start="4"><li>Récupérer, avec le controller, uniquement les groupes désirés :</li></ol><p><code>return $this-&gt;json( $products , Response::HTTP_OK, [], [&quot;groups&quot;=&gt;[&#39;product&#39;,&#39;brandLinked&#39;]] );</code></p><ol start="5"><li>A tester : on peut aussi sélectionner certains attributs (cf doc) et ignorer des attributs lors de la sérialisation :<br> Exp : <code>return $this-&gt;json($genreRepository-&gt;findAll(), 200, [], [AbstractNormalizer::IGNORED_ATTRIBUTES =&gt; [&#39;shows&#39;]]);</code></li></ol><h3 id="denormalisation" tabindex="-1">Dénormalisation <a class="header-anchor" href="#denormalisation" aria-label="Permalink to &quot;Dénormalisation&quot;">​</a></h3><p>Dans le cas où on veut pouvoir créer un enregistrement avec des infos liées à un autre enregistrement, si on ne dénormalise pas, ça va créer un nouvel enregistrement de l&#39;entité liée. On va utilsier le dénormaliseur cf fichier /src/Serializer/EntityDenormalizer.php Tout fichier placé ds le dossier /Serializer sera inspecté par Symfony lors de l&#39;utilisation du serializer. Ce dénormalizer permet de récupérer les infos liées à une entité à partir de son id. Il suffira de spécifier l&#39;id lors de la création du JSON sous la forme <code>{&quot;propriété&quot;:id }</code>.</p><h2 id="authentification-avec-un-json-web-token" tabindex="-1">AUTHENTIFICATION AVEC UN JSON WEB TOKEN <a class="header-anchor" href="#authentification-avec-un-json-web-token" aria-label="Permalink to &quot;AUTHENTIFICATION AVEC UN JSON WEB TOKEN&quot;">​</a></h2><p>Culture G : L&#39;authentification peut généralement se faire avec les sessions, l&#39;identifiant est dans les headers. Mais si&#39;l y a plusieurs serveurs, on peut plus retrouver le serveur qui détient le login, les serveurs vont être stateless et ne mémorisent pas l&#39;état, ils sont indépendants, le JWT va contenir les infos d&#39;authentification, il a 3 blocs : 1. entête(algo de chiffrage) 2. corps(claims=infos en JSON,dates de création et d&#39;expiration) 3. signature (signature qui valide le token). =&gt; LE JWT permet donc de ne pas avoir à faire des allers /retours entre serveurs et BDD, il est aussi utile pour les app mobiles et les API, et aussi on peut utiliser la clé privée pour être validée par un organisme public qui aurait accès à la clé publique. cf doc. <a href="https://github.com/lexik/LexikJWTAuthenticationBundle/blob/3.x/Resources/doc/index.rst#getting-started" target="_blank" rel="noreferrer">https://github.com/lexik/LexikJWTAuthenticationBundle/blob/3.x/Resources/doc/index.rst#getting-started</a></p><ol><li><p>Installation du composant lexik/jwt-authentication-bundle <code> composer require lexik/jwt-authentication-bundle</code></p></li><li><p>Générer les clés <code>php bin/console lexik:jwt:generate-keypair</code></p></li><li><p>Rajouter dans le .env</p></li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>    JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem</span></span>
<span class="line"><span>    JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem</span></span>
<span class="line"><span>    JWT_PASSPHRASE=</span></span></code></pre></div><ol start="4"><li>Dans config/packages/security.yaml</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>security:</span></span>
<span class="line"><span>    enable_authenticator_manager: true # Only for Symfony 5.4</span></span>
<span class="line"><span>    # ...</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    firewalls:</span></span>
<span class="line"><span>        login:</span></span>
<span class="line"><span>            pattern: ^/api/login</span></span>
<span class="line"><span>            stateless: true</span></span>
<span class="line"><span>            json_login:</span></span>
<span class="line"><span>                check_path: /api/login_check</span></span>
<span class="line"><span>                success_handler: lexik_jwt_authentication.handler.authentication_success</span></span>
<span class="line"><span>                failure_handler: lexik_jwt_authentication.handler.authentication_failure</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        api:</span></span>
<span class="line"><span>            pattern:   ^/api</span></span>
<span class="line"><span>            stateless: true</span></span>
<span class="line"><span>            jwt: ~</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    access_control:</span></span>
<span class="line"><span>        - { path: ^/api/login, roles: PUBLIC_ACCESS }</span></span>
<span class="line"><span>        - { path: ^/api,       roles: IS_AUTHENTICATED_FULLY }</span></span></code></pre></div><ol start="5"><li>Dans config/routes.yaml :</li></ol><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>api_login_check:</span></span>
<span class="line"><span>    path: /api/login_check</span></span></code></pre></div><p>Cette route a été créée automatiquement par lexikJWT.</p><ol start="6"><li>Pour s&#39;authentifier manuellement il faut copier le json des identifiants <code>{&quot;username&quot;:&quot;admin@gmail.com&quot;,&quot;password&quot;:&quot;admin&quot;}</code> où username est la propriété discriminante dans User.php dans le body de la requête et envoyer à /api/login_check ça va générer un token qu&#39;on va copier dans authorization-&gt;bearer ds postman lors de l&#39;accès aux routes protégées. =&gt; g pas compris comment c&#39;lié à l&#39;ACL ? =&gt; lire de la doc pour synthétiser</li></ol><p>Il faut avoir crée le user avec make:user avant.</p><p>RESUME POUR JWT 1/ créer le user avec make:user et mettre des id et mdp 2/ installer le bundle lexikJWT 3/ générer les clés 4/ configurer les fichiers 5/ aller sur la route <a href="http://localhost:8080/api/login_check" target="_blank" rel="noreferrer">api/login_check</a> 6/ envoyer le {&quot;<a href="mailto:username%22:%22admin@gmail.com" target="_blank" rel="noreferrer">username&quot;:&quot;admin@gmail.com</a>&quot;,&quot;password&quot;:&quot;admin&quot;} dans le body en POST 7/ récupérer le token Explications : la configuration via routes.yaml et services.yaml va permettre de gérer l&#39;authentification. Les infos de hashage du pwd et la vérification de la clé st dans le fichier security.yaml et .env. Automatiquement le token va être envoyé dans le header et contient le role donc va permettre ou non l&#39;accès à la route selon l&#39;ACL du security.yaml.</p><p>hasher de symfo en CLI bin/console security:hash-password</p>`,46),o=[r];function i(l,c,p,u,d,h){return s(),a("div",null,o)}const f=e(t,[["render",i]]);export{g as __pageData,f as default};
